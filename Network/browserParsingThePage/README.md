## 问题：浏览器从输入URL到看到页面发生了什么？

## 解答：

**简单回答：**
* DNS解析：将域名解析成IP地址
* 发起TCP连接：TCP三次握手
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束：TCP四次挥手

### 一、DNS解析
DNS 解析简单来说就是 URL 网址转换成对应的 IP 地址的过程。下面先了解一些基础概念：

#### 什么是 IP 地址？
IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，
它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址不好记忆，所以诞生了 URL 地址。

#### 什么是 URL？
URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。

```
scheme: // host.domain:port / path / filename ? abc = 123 # 456789
```

```
scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host         - 定义域主机（http 的默认主机是 www）
domain       - 定义因特网域名，比如 google.com
port         - 定义主机上的端口号（http 的默认端口号是 80）
path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename     - 定义文档/资源的名称
query        - 即查询参数
fragment     - 即 # 后的hash值，一般用来定位到某个位置
```

#### 什么是 DNS？
DNS 就是域名系统，全称是 **D**omain **N**ame **S**ystem，是一个统称的概念。

DNS 如何知道 URL 地址的对应 IP 地址呢？早期通过我们电脑上的hosts文件查找，随着互联网的设备越来越多，hosts已经不足以支撑那么多，需要一台 DNS 服务器帮助我们解析转换。

常见的DNS服务器商：
* OpenDNS
* Google DNS
* DNSPOD

浏览器输入地址到DNS服务器解析，并非一步到位，还存在一个查找的过程：浏览器缓存 → 系统缓存 → hosts → 路由器缓存→ ISP DNS 缓存 → 递归搜索。

![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/dns1.png?sign=e9d2415389349493687e65de98ff2ff8&t=1641891162)

如下，展示了一个可能的详细过程（Chrome浏览器）：
| 步骤名称 | 步骤描述 |
| ------- | -------- |
| 浏览器缓存 | 首先搜索浏览器的DNS缓存，看自身的缓存中是否有对应的条目，如果有且没有过期则解析到此结束。(缓存时间比较短，TTL默认是1000，且只能容纳1000条缓存)</br></br>注：查看浏览器的DNS缓存，可以使用 chrome://net-internals/#dns 来进行查看。（无效） |
| 系统缓存 | 如果浏览器缓存里没有找到需要的记录，浏览器会调用系统缓存里的记录。如果有则解析成功。</br></br>注：查看操作系统的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看。 |
| hosts文件 | 如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面有没有该域名对应的IP地址，如果有则解析成功。</br></br> 注：Windows上hosts文件位置，C:\Windows\System32\drivers\etc。 |
| 路由器缓存 | 如果还是没有找到需要的缓存，将前面的查询请求发给路由器，它一般会有自己的DNS缓存。如果有则解析成功。 |
| ISP DNS 缓存 | 如果还是没有，浏览器就会发起一个DNS的系统调用，向本地配置的首选DNS服务器发起域名解析请求。运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。</br></br>注：每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来 |
| 递归搜索 | 如果没有需要的缓存，你的ISP的DNS服务器会代替我们的浏览器发起迭代DNS解析请求，从根域名开始进行递归查询。</br></br>递归查询：主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果可能是所要查询的IP地址，也可能是一个失败的响应，表示无法查询到所需的IP地址。</br></br>迭代查询：本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。 |

如果经过以上的步骤，还没有解析成功，那么会进行如下步骤：
| 步骤名称 | 步骤描述 |
| ------- | -------- |
| NetBIOS名称缓存 | 操作系统就会查找 NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 |
| WINS 服务器 | 如果还没成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） |
| 广播查找 | 如果还没成功，那么客户端就要进行广播查找 |
| LMHOSTS文件 | 那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） |
| <font color="#ff0000">解析失败</font> | 只要前面的这些步骤中有一步可以解析成功，那就可以成功和目标计算机进行通信。但是如果还没有解析成功，那么这次解析失败，那就无法跟目标计算机进行通信。 |

#### DNS的优化与应用
1. **DNS缓存：** DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</br></br>
2. **DNS负载均衡(DNS重定向)：** DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</br></br>
3. 大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟
用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</br></br>
4. **dns-prefetch：** DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。

### 二、发起TCP连接
User-Agent（chrome浏览器）上访问url，通过dns解析拿到ip后，会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有tomcat、nginx等）80端口发起TCP的连接请求。

这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

#### TCP三次握手
![](https://7675-vuepress-7g6mefe5ad729c51-1258812673.tcb.qcloud.la/Image/2022/FrontEnd-Replay/Network/browserParsingThePage/tcp1.png?sign=1e178678860939e05234f5f09a9b4dac&t=1641891156)

1. 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。）

2. 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。）

3. 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。）

##### 1.1 什么是半连接队列？
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于SYN-ACK 重传次数的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

##### 1.2 ISN(Initial Sequence Number)是固定的吗？
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。
三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

##### 1.4 三次握手过程中可以携带数据吗？
其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

##### 1.4 SYN攻击是什么？
服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```shell
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：
* 缩短超时（SYN Timeout）时间
* 增加最大半连接数
* 过滤网关防护
* SYN cookies技术

#### TCP状态：
* LISTEN： 侦听来自远方TCP端口的连接请求；
* SYN-SENT：在发送连接请求后等待匹配的连接请求；
* SYN-RECEIVED： 在收到和发送一个连接请求后等待对连接请求的确认；
* ESTABLISHED： 代表一个打开的连接，数据可以传送给用户；
* FIN-WAIT-1： 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
* FIN-WAIT-2： 从远程TCP等待连接中断请求；
* CLOSE-WAIT： 等待从本地用户发来的连接中断请求；
* CLOSING：等待远程TCP对连接中断的确认；
* LAST-ACK： 等待原来发向远程TCP的连接中断请求的确认；
* TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认；
* CLOSED： 没有任何连接状态；

### 三、连接结束

#### TCP四次挥手
建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
1. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
1. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
1. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

在socket编程中，任何一方执行close()操作即可产生挥手操作。

2.1 挥手为什么需要四次？


**参考：**
1. [史上最详细的经典面试题 从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072#comment)
1. [从URL输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)
1. [字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261#heading-0)
1. [DNS域名解析的过程](https://www.yuque.com/gdnnth/fe-optimise/ogdd8t)
1. [DNS是干什么的？修改hosts的原理又是什么？](https://www.bilibili.com/video/BV1Yx411p7KD?from=search&seid=4297856666634992476&spm_id_from=333.337.0.0)
1. [面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606)